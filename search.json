[{"title":"使用说明","path":"/2024/04/03/使用说明/","content":"记录一下怎么发blog，一年没用，忘记了&gt;.&lt; 创建一个新的博客： 1npx hexo new post &quot;name&quot; 渲染md文件为博客页面： 1npx hexo g 在本地启动，预览： 1npx hexo s 部署： 1npx hexo d 部署失败的话，清除缓存再执行部署： 1npx hexo clean"},{"title":"排序算法","path":"/2023/04/18/排序算法/","content":"记录一下各种排序算法的实现，方便回顾。 冒泡排序选择排序归并排序核心思想：二叉树遍历中的后序遍历，先排左边，再排右边，在后序位置合并子树。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MergeSoet &#123; // 用于辅助合并有序数组 private static int[] temp; public static int[] sortArray(int[] nums) &#123; // 先给辅助数组开辟内存空间 temp = new int[nums.length]; // 排序整个数组（原地修改） sort(nums, 0, nums.length - 1); return nums; &#125; // 定义：将子数组 nums[lo..hi] 进行排序 private static void sort(int[] nums, int lo, int hi) &#123; if (lo == hi) &#123; // 单个元素不用排序 return; &#125; // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2 int mid = lo + (hi - lo) / 2; // 先对左半部分数组 nums[lo..mid] 排序 sort(nums, lo, mid); // 再对右半部分数组 nums[mid+1..hi] 排序 sort(nums, mid + 1, hi); // 将两部分有序数组合并成一个有序数组 merge(nums, lo, mid, hi); &#125; // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组 private static void merge(int[] nums, int lo, int mid, int hi) &#123; // 先把 nums[lo..hi] 复制到辅助数组中 // 以便合并后的结果能够直接存入 nums for (int i = lo; i &lt;= hi; i++) &#123; temp[i] = nums[i]; &#125; // 数组双指针技巧，合并两个有序数组 int i = lo, j = mid + 1; for (int p = lo; p &lt;= hi; p++) &#123; if (i == mid + 1) &#123; // 左半边数组已全部被合并 nums[p] = temp[j++]; &#125; else if (j == hi + 1) &#123; // 右半边数组已全部被合并 nums[p] = temp[i++]; &#125; else if (temp[i] &gt; temp[j]) &#123; nums[p] = temp[j++]; &#125; else &#123; nums[p] = temp[i++]; &#125; &#125; &#125;&#125; 快速排序核心思想：二叉树遍历中的前序遍历，在前序位置排序好元素p，再将剩下的元素排序好。 代码框架： 123456789101112void sort(int[] nums, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] int p = partition(nums, lo, hi); // 去左右子数组进行切分 sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125; 代码实现：（注意边界条件） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Quick &#123; public static void sort(int[] nums) &#123; // 为了避免出现耗时的极端情况，先随机打乱 shuffle(nums); // 排序整个数组（原地修改） sort(nums, 0, nums.length - 1); &#125; private static void sort(int[] nums, int lo, int hi) &#123; if (lo &gt;= hi) &#123; return; &#125; // 对 nums[lo..hi] 进行切分 // 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi] int p = partition(nums, lo, hi); sort(nums, lo, p - 1); sort(nums, p + 1, hi); &#125; // 对 nums[lo..hi] 进行切分 private static int partition(int[] nums, int lo, int hi) &#123; int pivot = nums[lo]; // 关于区间的边界控制需格外小心，稍有不慎就会出错 // 我这里把 i, j 定义为开区间，同时定义： // [lo, i) &lt;= pivot；(j, hi] &gt; pivot // 之后都要正确维护这个边界区间的定义 int i = lo + 1, j = hi; // 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖 while (i &lt;= j) &#123; while (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123; i++; // 此 while 结束时恰好 nums[i] &gt; pivot &#125; while (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123; j--; // 此 while 结束时恰好 nums[j] &lt;= pivot &#125; // 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot if (i &gt;= j) &#123; break; &#125; swap(nums, i, j); &#125; // 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大 swap(nums, lo, j); return j; &#125; // 洗牌算法，将输入的数组随机打乱 private static void shuffle(int[] nums) &#123; Random rand = new Random(); int n = nums.length; for (int i = 0 ; i &lt; n; i++) &#123; // 生成 [i, n - 1] 的随机数 int r = i + rand.nextInt(n - i); swap(nums, i, r); &#125; &#125; // 原地交换数组中的两个元素 private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 复杂度分析： 时间复杂度：二叉树递归的时间复杂度主要看节点的个数，每次执行的复杂度就是每个节点代表的子数组 nums[lo..hi] 的长度，所以总的时间复杂度就是整棵树中数组元素的个数。假设数组元素个数为N，那么二叉树每一层的元素个数之和就是O(N)，如果分界点分布均匀，树的层数为 O(logN)，所以理想的总时间复杂度为 O(NlogN)。快速排序的效率存在一定随机性，如果每次 partition 切分的结果都极不均匀，快速排序就退化成选择排序了，树高为 O(N)，每层节点的元素个数从 N 开始递减，总的时间复杂度为 O(N^2)。 空间复杂度：由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 O(logN)。","tags":["算法题","排序"],"categories":["算法题"]},{"title":"位运算","path":"/2023/03/20/位运算/","content":"做反转字符串的时候发现原码什么的都忘了，恶补了一下，在此记录。 Java支持的位运算 位与（&amp;）：二元运算符，两个为1时结果为1，否则为0 位或（｜）：二元运算符，两个其中有一个为1时结果就为1，否则为0 位异或（^）：二元运算符，两个数同时为1或0时结果为1，否则为0 位取非（～）：一元运算符，取反操作 左移（&lt;&lt;）：一元运算符，按位左移一定的位置。高位溢出，低位补符号位，符号位不变。 右移（&gt;&gt;）：一元运算符，按位右移一定的位置。高位补符号位，符号位不变，低位溢出。 无符号右移（&gt;&gt;&gt;）：一元运算符，符号位（即最高位）保留，其它位置向右移动，高位补零，低位溢出。 位运算规则Java数值位运算会把十进制转换为二进制计算，再把二进制转换为十进制输出。二进制运算规则如下： 对于有符号数据（int型在Java中占4B，也就是16bit）： 最高位为符号为，0表示正数，1表示负数 正数的原码，反码和补码都一样，三码合一 负数的反码：符号位保持不限，其他位取反，补码：补码 + 1 0的反码和补码都是0 计算机的运算的时候，都是将原码转成补码进行运算的 逻辑运算与运算相同位置的比特进行与运算，两个位置均为1，结果为1，否则为0 以 4 &amp; -5为例： 正数4的原码与补码相同：00000000 0000000 00000000 00000100 负数-5： 原码：10000000 00000000 00000000 00000101 反码：11111111 11111111 11111111 11111010 补码：11111111 11111111 11111111 11111011 可以得到运算结果为：00000000 00000000 00000000 00000000。结果为0。 或运算两个数相同位置的比特进行或运算，若其中一个为1则结果为1，否个结果为0。 异或运算两个数相同位置的比特进行或运算，若两个数均为0或1，则结果为0，否者为1。 用例 在Leetcode334反转字符串的时候，发现可以用三行异或来交换两个位置的字符 123s[l] ^= s[r]; //构造 a ^ b 的结果，并放在 a 中 s[r] ^= s[l]; //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b s[l] ^= s[r]; //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换 取反运算若位数为0，则取反后为1，若为1，取反后为0。 位移操作左移规则：符号位不变，高位溢出截断，低位补零。比如 -1 &lt;&lt; 2 &#x3D; -4 。 右移规则：符号位不变，低位溢出截断，高位用符号位填充。如：8 &gt;&gt; 2 &#x3D; 2。 无符号右移规则：高位填充0，低位溢出。如-1&gt;&gt;&gt;1&#x3D;2147483647","tags":["Java"],"categories":["计算机基础"]},{"title":"leetcode-239:滑动窗口最大值","path":"/2023/03/19/leetcode-239-滑动窗口最大值/","content":"题目描述 给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 输入描述 整数数组 示例1 输入 nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3 输出 [3, 3, 5, 5, 6, 7] 思路 用单调队列实现，队列维护窗口中的最大值（的索引）以及可能成为最大值（的索引）的。 最大值放在出队口，设置pop和push规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 代码实现1234567891011121314151617181920212223242526272829303132//利用双端队列手动实现单调队列/** * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可 * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标) */class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); int n = nums.length; int[] res = new int[n - k + 1]; int idx = 0; for(int i = 0; i &lt; n; i++) &#123; // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点 // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出 while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1)&#123; deque.poll(); &#125; // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出 while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123; deque.pollLast(); &#125; deque.offer(i); // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了 if(i &gt;= k - 1)&#123; res[idx++] = nums[deque.peek()]; &#125; &#125; return res; &#125;&#125; 总结 单调队列只要维护最大值（的索引）和最大值后面可能成为最大值的就行； 每次push都按照从后往前的顺序和队列中的值比较； 注意最大值已经不在窗口的时候将其poll掉；","tags":["算法题","队列","单调队列"],"categories":["算法题"]},{"title":"leetcode-92:反转部分链表","path":"/2023/03/17/leetcode-92-反转部分链表/","content":"题目描述 给你单链表的头指针head和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置left到位置 right 的链表节点，返回反转后的链表 。 输入描述 索引从1开始 示例1 输入 head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4 输出 [1,4,3,2,5] 示例2 输入 head &#x3D; [5], left &#x3D; 1, right &#x3D; 1 输出 [5] 思路 递归： 需要首先考虑反转链表前n个节点的情况，注意此时newHead 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 newHead 连接上。 接着考虑反转一部分的情况，如果索引区间[m, n]左边界为1，即上述的反转前n个节点的情况 如果 m != 1 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 m 个元素开始反转对吧；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 m - 1 个元素开始的；那么对于 head.next.next 呢…… 代码实现123456789101112131415161718192021222324252627282930class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; if(left == 1) &#123; // 相当于反转前n个节点// ListNode newHead = reverseN(head, right); return reverseN(head, right); &#125; head.next = reverseBetween(head.next, left - 1, right - 1); return head; &#125; // 反转链表的前n个节点 // 后继节点 ListNode successor = null; public ListNode reverseN(ListNode head, int n) &#123; if (n == 1) &#123; successor = head.next; return head; &#125; // 以head.next为起点，反转前n-1个节点 ListNode newHead = reverseN(head.next, n - 1); head.next.next = head; // 让反转后的head节点与后面的节点连接起来 head.next = successor; return newHead; &#125;&#125; 总结 反转前n个的时候和反转整个链表差不多，就是需要特别注意保留第n+1节点 反转一部分链表就是让left递归到left==1，然后用反转前n+1的思想解决问题 任重而道远啊！","tags":["算法题","链表","递归"],"categories":["算法题"]},{"title":"leetcode-206:反转链表","path":"/2023/03/17/leetcode-206-反转链表/","content":"题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 输入描述 示例1 输入 head &#x3D; [1,2,3,4,5] 输出 [5,4,3,2,1] 示例2 输入 head &#x3D; [1,2] 输出 [2,1] 示例3 输入 head &#x3D; [] 输出 [] 思路 双指针法：定义prev，cur，temp三个指针遍历整个指针 递归： 递归调用下一个节点，并接受返回值（想象这个函数已经帮你翻转了后面的节点，并返回了自己的头结点） 明确每层递归的逻辑：需要获取当前节点cur的下一个节点nxt（该节点nxt是翻转后的最后一个节点），我们将next的next指向cur，返回之前递归调用的新的头结点newHead 代码实现123456789101112131415class Solution &#123; // 双指针遍历 public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode cur = head; ListNode temp = null; while (cur != null) &#123; temp = cur.next; cur.next = prev; prev = cur; cur = temp; &#125; return prev; &#125;&#125; 123456789101112131415161718class Solution &#123;\t// 递归 public ListNode reverseList(ListNode head) &#123; // 明确递归条件，如果是空指针或者只有一个节点的链表不需要反转，直接返回 if(head == null || head.next == null) &#123; return head; &#125; // 进入递归 ListNode newHead = reverseList(head.next); // 开始反转，下一个节点的next指针指向自己，并让自己的next节点指向null head.next.next = head; head.next = null; return newHead; &#125;&#125; 总结 递归还是厉害啊，努力学习！","tags":["算法题","双指针法","链表， 递归"],"categories":["算法题"]},{"title":"姿态估计评价指标","path":"/2023/03/14/姿态估计评价指标/","content":"记录姿态估计中经常用到的几种评价指标 姿态估计评价指标PCKPercentage of Correct Keypoints：正确估计出关键点的百分比$$P C K_i^k&#x3D;\\frac{\\sum_i \\delta\\left(\\frac{d_i}{d} \\leq T_k\\right)}{\\sum_i 1}$$$$d_i$$表示第i个关节点的预测值和groundtruth的欧式距离 $d$是一个人体的尺度因子，每个公开数据集的计算方法不同 $i$表示关节点的编号 $\\delta()$ 表示如果条件成立，那么$\\delta()$&#x3D;1 表示检测出的关节点与对应的groundtruth间的归一化距离小于设定阈值的比例，$T_k$是人工设定的阈值，大于0.01小于0.1 OKSObject Keypoint Similarity：启发自目标检测的IOU，用来衡量预测关键点与groundtruth的相似度$$O K S_p&#x3D;\\frac{\\sum_i \\exp \\left{-d_{p i}^2 &#x2F; 2 S_p^2 \\sigma_i^2\\right} \\delta\\left(v_{p i}&gt;0\\right)}{\\sum_i \\delta\\left(v_{p i}&gt;0\\right)}$$ $p$是groundtruth中的某个人，$p^i$表示其关键点 $d_p{i}$表示关键点与groundtruth的欧式距离 $v_p{i}&#x3D;1$表示关键点可见，$v_p{i}&#x3D;2$表示关键点有遮拦但已标注 $S_p$表示groundtruth p的尺寸因子，其值为行人检测框面积的平方根：$S_p^2&#x3D;wh$，$w$和$h$分别为检测框的宽和高 $\\sigma_i$是第$i$个关键点的归一化因子，和其标注难易有关，通过对所有样本的人工标注和真实值的统计标准差，$\\sigma$ 越大表示此类型的关键点越难标注。 p.s. COCO数据集中的5000个样本统计处17类关键点的归一化因子，$\\sigma$的取值为：**{鼻子：0.026，眼睛：0.025，耳朵：0.035，肩膀：0.079，手肘：0.072，手腕：0.062，臀部：0.107，膝盖：0.087，脚踝：0.089}**，因此此值可作为常数，如果使用的关键点类型不在此当中，则另外计算。 APAverage Precision：平均准确率（此处只考虑一个人的情况）$$A P&#x3D;\\frac{\\sum_p \\delta\\left(o k s_p&gt;T\\right)}{\\sum_p 1}$$表示所有图片的OKS大于阈值$T$的百分比($T$是人为给定的)。 MPJPEMean Per Joint Postion Error：平均关键点误差（用于3D姿态估计） 所有预测节点与groundtruth的欧式距离的平均 P-MPJPEProcrustes analysis MPJPE：旋转变换（先对其一个关键点坐标，其余的以其为相对表示）后的MPJPE","tags":["wifi sensing","posing"]},{"title":"pose cross environment","path":"/2023/03/02/pose-cross-environment/","content":"记录一下找到的几种针对跨环境问题的姿态估计 姿态估计跨环境问题调研任务有一个或几个环境的数据 在新的环境中实现相同的效果 现有研究情况 领域 模型 预处理 主要方法 实验 时间 WiFi Winect 角度谱减法 识别运动肢体+盲源分离+关节点轨迹(DNN) 原地运动 2021ubicom RFID Meta-Pose 连续相位差+RNN meta learning + fine tuning 原地运动 2022J of RFID CV Cycle 循环一致性原则，训练两个对抗网络 2017ICCV WiFi EI 3层CNN FCN预测后与源数据一起送进鉴别器（域对抗） 活动识别 2018Mobicom WiFi GoPose 角度谱减法 四个接收机的2DAoA输入进网络，进行姿态识别 Winect效果： Meta-Pose效果：指标为12个节点的平均误差 Cycle GAN陌生数据 + 想要的标准数据 &#x3D; 陌生数据在标准数据中的表示 for example ：手机拍的照片 + 莫奈油画 &#x3D; 莫奈油画版本的手机拍的照片 还需要看的： 引文11 12提到的对抗生成网络实现跨环境的论文 引文9提到的自己之前的工作","tags":["wifi sensing","posing"],"categories":["文献阅读"]},{"title":"leetcode-142-环形链表II","path":"/2023/02/27/leetcode-142-环形链表II/","content":"题目描述 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 输入描述 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 示例1 输入 head &#x3D; [3,2,0,-4], pos &#x3D; 1 输出 返回索引为1的链表节点 示例2 输入 head &#x3D; [1], pos &#x3D; -1 输出 null 思路首先需要判断是否存在环，只需要定义快慢指针，一个一次走两格，一个一次走一格，这样只要有环一定会相遇（与相交链表判断一样），接着要找环的入口。 假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点节点数为y。 从相遇节点再到环形入口节点节点数为z。 那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针，（y+z）为 一圈内节点的个数A。 因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2： (x + y) * 2 = x + y + n (y + z) 两边消掉一个（x+y）: x + y = n (y + z) 因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。 所以要求x ，将x单独放在左面：x = n (y + z) - y , 再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。 所以可以看出，在快慢指针相遇时，头节点到入口的距离和相遇节点到入口的距离是一样的！ 代码实现123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fastIndex = head; ListNode slowIndex = head; while(fastIndex != null &amp;&amp; fastIndex.next != null)&#123; fastIndex = fastIndex.next.next; slowIndex = slowIndex.next; if(fastIndex == slowIndex)&#123; ListNode index1 = head; ListNode index2 = slowIndex; while (index1 != index2)&#123; index2 = index2.next; index1 = index1.next; &#125; return index1; &#125; &#125; return null; &#125;&#125; 总结 首先判断是否有环，利用快慢指针 然后可以推导出一个到入口距离相等的两个点，此时重新定义两个指针同步就可以找到了！","tags":["算法题","链表"],"categories":["算法题"]},{"title":"Winect","path":"/2023/02/20/Winect/","content":"2018-Ubicom 目的自由活动跟踪 与环境、人、位置无关，在各种环境下实现厘米级的自由活动跟踪。 创新点&#x2F;方法： 肢体识别（基于AoA）：盲源分离与移动肢体的识别 -&gt; 得到轨迹 利用运动学模型，从多个运动的肢体分解关节点 WiPose只适用于预定义的活动（WiMose变成了可以动的，但还是预定义的） 盲源分离识别动的躯干， 实验设计：设备：一发（2ant）三收（3ant） 识别移动肢体： L型接收天线阵列 -&gt; 二维到达角估计 谱减法 -&gt; 去除环境噪声（人站在原地不动） 根据方位角和俯仰角谱的峰值确定运动肢体的个数（用一百个packet来非参聚类），根据识别到的角度可以根据先验知识确定是哪个肢体 分离运动肢体信号： 找到最敏感的子载波对（movement energy ratio） 盲源分离（懒得看下面的了，很复杂，用不太到） 关节点分解： 点云模型，深度网络学习肢体位置点云和关节点位置点云的关系 关于肢体学运动的balabala 应用：结论： 关节点估计效果： 跨环境效果：几乎不受环境同样影响，但暗的时候效果不好，不知道为啥，差了大概40% 肢体识别的准确率：98.5% 总结：缺陷：启示： 盲源分流有点扯淡，但去除环境分量的方法值得学习 只学习肢体位置和关节点的关系，这样也可以从根本上解决客观依赖","tags":["wifi sensing","pose"],"categories":["文献阅读"]},{"title":"leetcode-242:有效的字母异位词","path":"/2023/02/18/leetcode-242-有效的字母异位词/","content":"题目描述 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 输入描述 给定字符串只有小写字母（意思就是表长只有26就可以了，ASCII值也是连续的） 示例1 输入 s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot; 输出 true 示例2 输入 s &#x3D; &quot;rat&quot;,t &#x3D; &quot;car&quot; 输出 false 思路首先判断两个字符串长度一样不，不一样直接return，一样的话再创建一个26长度的哈希表（此处用数组就行了），一块遍历两个字符串，根据ASCII值决定在表中的位置，一个加一个减，最后表中全0代表一样了 代码实现123456789101112131415class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; int[] alpha = new int[26]; for(int i = 0; i&lt; s.length(); i++) &#123; alpha[s.charAt(i) - &#x27;a&#x27;] ++; alpha[t.charAt(i) - &#x27;a&#x27;] --; &#125; for(int i=0;i&lt;26;i++) if(alpha[i] != 0) return false; return true; &#125;&#125; 总结 第一次做哈希映射的题，继续加油吧","tags":["算法题","哈希"],"categories":["算法题"]},{"title":"leetcode-160:相交链表","path":"/2023/02/18/leetcode-160-相交链表/","content":"题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 输入描述 输入链表不存在环 示例1 输入 listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5] 输出 8 示例2 输入 listA &#x3D; [2,6,4], listB &#x3D; [1,5] 输出 null 思路如果两个链表存在相交的部分，则两个链表长度分别为a+c，b+c，则a+c + b+c &#x3D; b+c + a+c。所以一直循环会在公共起点处相遇，如果不存在相交，则a + b &#x3D; b + a，所以在终点处相遇。 代码实现1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 总结 累死于初中数学的追赶题，挺有趣的，只用了O(n)（也好像是O(n+m)？）时间复杂度","tags":["算法题","链表"],"categories":["算法题"]},{"title":"leetcode-19:删除链表的倒数第n个结点","path":"/2023/02/14/leetcode-19-删除链表的倒数第n个结点/","content":"题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 输入描述 n不大于链表长度，所以不用考虑超出长度的情况。 示例1 输入 head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出 [1,2,3,5] 示例2 输入 head &#x3D; [1], n &#x3D; 1 输出 [] 思路快慢指针指向虚拟头结点，快指针向前n步，然后快慢指针一起向后移动直至快指针指向尾结点 代码实现123456789101112131415161718192021class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; for(int i = 0;i &lt; n;i++) &#123; fastIndex = fastIndex.next; &#125; while(fastIndex.next != null) &#123; fastIndex = fastIndex.next; slowIndex = slowIndex.next; &#125; slowIndex.next = slowIndex.next.next; return dummyNode.next; &#125;&#125; 总结 双指针的应用，注意while结束的时候让慢指针指向倒数第n个结点的前一个结点（便于删除） 看了题解秒杀hhh","tags":["算法题","链表","双指针法"],"categories":["算法题"]},{"title":"leetcode-209:长度最小的子数组","path":"/2023/02/10/leetcode-209-长度最小的子数组/","content":"题目描述 找出该数组中满足其和 ≥target的长度最小的连续子数组 [numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。 输入描述 一个含有n个正整数的数组和一个正整数target。 示例1 输入 target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出 2 解释 子数组 [4,3] 是该条件下的长度最小的子数组 示例2 输入 target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1] 输出 0 思路 暴力搜索：定义两层for循环，遍历所有的起点和终点位置，找到符合条件的最短的数组，但时间复杂度过高，Java会保超时，时间复杂度O（n^2）。 滑动窗口：只定义一层for循环，遍历结束位置，但精妙之处在于，实现定义一个起点为0的指针left，从第一次找到sum&gt;&#x3D;target的时候开始，定义一个while循环（注意是while，因为可能有减去两个的时候sum还大于target）再让sum-=[left++]，最终实现只用一个for循环遍历，时间复杂度O（n）。 代码实现1234567891011121314151617class Solution &#123; //暴力搜索 public int minSubArrayLen(int target, int[] nums) &#123; int minLength = Integer.MAX_VALUE; for(int i = 0;i &lt;= nums.length - 1;i++) &#123; int sum = 0; for(int j = i;j &lt;= nums.length - 1;j++) &#123; sum += nums[j]; if(sum &gt;= target) &#123; minLength = Math.min(minLength, j - i + 1); break; &#125; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 12345678910111213141516class Solution &#123;\t//滑动窗口 public int minSubArrayLen(int target, int[] nums) &#123; int sum = 0; int left = 0; int result = Integer.MAX_VALUE; for(int right = 0;right &lt;= nums.length - 1;right++) &#123; sum += nums[right]; while(sum &gt;= target) &#123; result = Math.min(result, right - left +1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 总结 暴力搜索就写了半天，还是太菜了，忘记距离的计算需要+1了。 遍历结束位置而非开始位置。","tags":["算法题","数组","滑动窗口"],"categories":["算法题"]},{"title":"leetcode-977:有序数组的平方","path":"/2023/02/09/leetcode-977-有序数组的平方/","content":"题目描述 给你一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按&#96;非递减顺序排序。 输入描述 非递减数组 示例1 输入： nums &#x3D; [-4,-1,0,3,10] 输出： [0,1,9,16,100] 解释： 平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例2： 输入： nums &#x3D; [-7,-3,2,3,11] 输出： [4,9,9,49,121] 思路可以直接暴力排序 i.e.全部平方之后排序，但时间复杂度过高，使用快排也是O(n+nlogn)，考虑到输入给的是非递减数组，所以最大值肯定在开头或结尾，可以考虑双指针法，从两边向中间逼近，注意考虑while循环的条件，要把leftIndex &#x3D; rightIndex的时候考虑进去。 代码实现12345678910111213141516171819class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int[] result = new int[nums.length]; int i = 0; int j = nums.length - 1; int resultIndex = nums.length - 1; while(j &gt;= i) &#123; if(nums[j] * nums[j] &gt;= nums[i] * nums[i]) &#123; result[resultIndex] = nums[j] * nums[j]; j--; &#125;else &#123; result[resultIndex] = nums[i] * nums[i]; i++; &#125; resultIndex--; &#125; return result; &#125;&#125;","tags":["算法题","双指针法","数组"],"categories":["算法题"]},{"title":"RF-diary","path":"/2023/02/09/RF-diary/","content":"目的：通过无线信号描述人的活动以及与物品的交互。 creating a system that observes people at home, and automatically generates a transcript of their everyday life。 创新点&#x2F;方法： 训练阶段将家庭平面图（标记家具等静态物体的大小和位置）输入网络中 将RF-diary提取到的特征与现有的视频字幕模型的特征对其到相同的空间 实验设计： 硬件条件：两个垂直和水平排列的12天线天线阵列，发射5.4-7.2GHz的FMCW 模型设计： RF Siganl： Input: 90-frame RF heatmaps（3 seconds） Network: 20(12 + 6 + 2)ResNet Floormap representation: Input:以人为中心建立坐标系，每个实例中用5个元素描述物体对象：L,W,x(t),y(t),theat Network:2 fully connected network Embedding layer: $u &#x3D; \\psi (u_{rf}\\oplus u_{flr})$$$u &#x3D; \\psi (u_{rf}\\oplus u_{flr})$$ $\\psi$指的是2层全连接 特征对齐： 对齐方法：先采一对RF+floormap特征与RGB视频作为配对数据（具有相同的语义），然后利用配对视频与现有的视频字幕数据集中视频具有相同模态的特点，建立桥梁； 具体实施：将有（RF+Floormap）配对的数据和无（RF+Floormap）配对数据混在一起训练一个视频字幕模型，然后迁移，但因为特征分布不同，会过拟合，所以利用让两个特征分布相似来解决（视频编码阶段提取两种特征Mixed_5c与空间平均池化后的特征），表现在loss上就是：$$\\begin{aligned}\\mathcal{L}&#x3D; &amp; \\mathcal{L}{\\text {cap }}\\left(\\mathbf{u}^P\\right)+\\mathcal{L}{\\text {cap }}\\left(\\mathbf{v}n^P\\right)+\\mathcal{L}{\\text {cap }}\\left(\\mathbf{v}n^U\\right) \\&amp; +\\mathcal{L}{\\text {pair }}\\left(\\mathbf{u}^P, \\mathbf{v}n^P\\right) \\&amp; +\\mathcal{L}{\\text {unpair }}\\left(\\mathbf{v}_n^P, \\mathbf{v}n^U\\right)+\\mathcal{L}{\\text {unpair }}\\left(\\mathbf{v}_m^P, \\mathbf{v}_m^U\\right) .\\end{aligned}$$ Loss： Lcap：针对的是字幕生成模型，第一个为最终目标，后两个应该是在混合训练的时候优化了； Lpair：针对的是embedding layer（maybe），让提取到的特征与具有相同语义的视频有最小的分布差； Lunpair：针对的是视频数据之间的分布差，不懂这个loss是怎么参与网络优化的 困惑： 用混合的视频数据训练了一个视频字幕生成模型，迁移下来时候，不就是输入带RF的数据集嘛，咋实现对两套视频数据分布差缩小的优化的（第三行unpair的loss），or实现之后又怎么反馈到其他部分啊？是在训练视频编码器的时候就做吗？但是在5.1中说他是直接用的别人训练好的模型提取视频特征。 怎么训练的&#x2F;优化的到底是啥？ 猜想1（整体训练）: 事先训练好特征提取网络、视频编码网络 （混合）视频数据训练出来的视频字幕模型 以3+1+2个loss最小为目标，不断优化captioning generation网络（基于注意力机制的LSTM模型） 但是这样训练，视频都已经用过了 猜想2： 未训练的特征提取网络 （混合）视频数据预训练出来的视频字幕模型 Question：输入的数据集应该是对应的rf+video+描述，得到一个能根据rf生成字幕的（或许是用混合数据预训练的）模型，然后对骨架编码器、floormap编码器、embedding层、 实验： 数据集：RF Captioning Dataset（synchronized RF signals, RGB videos, floormaps, human-labeled captions） floormaps：cabinet, table, bed, wardrobe, shelf, drawer, stove, fridge, sink, sofa, television, door, window, air conditioner, bathtub, dishwasher, oven, bedside table #environments #clips avg len #action types #object types #sentences #words vocab len 10 1035 31.3s 157 38 3610 77762 6910 8.99hrs 实验结果： 定量结果： 消融实验： 3D Skeleton: 3D skeletons &gt; 2D skeletons &gt; Locations Person-Centric Floormap: 应用：结论： 可见场景中与视频字幕模型效果相当（41.5 BLEU + 26.7 CIDEr VS 41.1 BLEU + 27.0 CIDEr） 遮蔽与黑暗场景效果依旧 总结： 多模态应用的思想：找到媒介，然后全部对齐 缺陷： 家具不能动 采集原始数据比较困难 启示：","tags":["wifi sensing","posing"],"categories":["文献阅读"]},{"title":"leetcode-704:二分查找","path":"/2023/02/09/leetcode-704-二分查找/","content":"题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 输入描述 可以假设 nums 中的所有元素是不重复的。 示例1 输入： nums &#x3D; [-1,0,3,5,9,12],target &#x3D; 9 输出： 4 解释： 9 出现在 nums 中并且下标为 4 示例2 输入： nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出： -1 解释： 2 不存在 nums 中因此返回 -1 思路二分搜索法查找目标值。需要特别注意搜索区间，如果循环中定义的是左闭右闭（即left&lt;&#x3D;right）那么在缩小区间时需要变为mid+-1（因为闭区间上已经搜索过值了，避免重复搜索导致超出时间限制）。 代码实现12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left&lt;=right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) &#123; return mid; &#125; else if(nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 总结 循环条件无比要注意啊，不然编译过了，测试不通过（超出时间限制） 左闭右开也可以，缩小区间的时候不要+-1了","tags":["算法题","数组","二分法"],"categories":["算法题"]},{"title":"leetcode-511:游戏玩法分析I","path":"/2023/02/08/leetcode-511-游戏玩法分析I/","content":"题目描述 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。 leetcode-551 输入描述 create table activity ( player_id int, device_id int, event_date date, games_played int); insert into activity values(1, 2, ‘2016-03-01’, 5),(1, 2, ‘2016-05-02’, 6),(1, 3, ‘2017-06-25’, 1),(3, 1, ‘2016-03-02’, 0),(3, 4, ‘2018-07-03’, 5); 思路 按照 player_id 将 activity 分组 使用 min 函数，求出日期的最小值 代码实现123select player_id, min(event_date) as first_login from activitygroup by player_id; 总结 第一次见date类型的，不知道怎么比较 没想到用GROUP分组","tags":["算法题","MySql"],"categories":["数据库"]},{"title":"HashTable","path":"/2023/02/08/HashTable/","content":"哈希表也称散列表，英文名Hash table。 哈希表是根据关键码的值而直接进行访问的数据结构。 “数组就是一张哈希表” ：数组的索引下标就对应哈希表中的关键码，通过下标直接访问数组中的元素。 作用：一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里。 要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。 我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。 将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。 哈希函数将学生姓名直接映射为哈希表上的索引，通过查询索引下标快速判断学生是否在学校里。 如果hashCode值大于tableSize，就对其取模，如果学生数量大于哈希表大小，会导致几位学生的名字同时影射到哈希表的同一个索引下标的位置。 哈希碰撞小王和小李都映射到了索引下标1的位置成为哈希碰撞（Collisions）。 一般通过拉链法与线性探测法解决。 拉链法：两个元素都被存在索引1的位置上，存储在链表中，由此可以通过索引找到两个元素。 “其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。” 线性探测法保证哈希表大小（tableSize）大于数据规模（dataSize）。依靠哈希表中的空位来解决碰撞问题。 “例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize。” 总结用处：快所安段一个元素是否出现在集合里 弊端：牺牲空间换取时间（要使用额外的数组、set或者map来存放数据）","categories":["数据结构"]},{"title":"Hello World","path":"/2023/02/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于我","path":"/about/index.html","content":"I’m GlonhChiang。I’m studying for a master degree at BUPT (2022.9 ~ 2025.6).Graduated from NJUPT(2018.9 ~ 2022.6).I mainly write Python and Java codes.I now focus on WiFi sensing and Deep Learning."}]