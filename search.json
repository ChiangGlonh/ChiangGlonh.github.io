[{"title":"leetcode-160:相交链表","path":"/2023/02/18/leetcode-160-相交链表/","content":"题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 输入描述 输入链表不存在环 示例1 输入 listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5] 输出 8 示例2 输入 listA &#x3D; [2,6,4], listB &#x3D; [1,5] 输出 null 思路如果两个链表存在相交的部分，则两个链表长度分别为a+c，b+c，则a+c + b+c &#x3D; b+c + a+c。所以一直循环会在公共起点处相遇，如果不存在相交，则a + b &#x3D; b + a，所以在终点处相遇。 代码实现1234567891011public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 总结 累死于初中数学的追赶题，挺有趣的，只用了O(n)（也好像是O(n+m)？）时间复杂度","tags":["算法题","链表"],"categories":["算法题"]},{"title":"leetcode-19:删除链表的倒数第n个结点","path":"/2023/02/14/leetcode-19-删除链表的倒数第n个结点/","content":"题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 输入描述 n不大于链表长度，所以不用考虑超出长度的情况。 示例1 输入 head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出 [1,2,3,5] 示例2 输入 head &#x3D; [1], n &#x3D; 1 输出 [] 思路快慢指针指向虚拟头结点，快指针向前n步，然后快慢指针一起向后移动直至快指针指向尾结点 代码实现123456789101112131415161718192021class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummyNode = new ListNode(0); dummyNode.next = head; ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; for(int i = 0;i &lt; n;i++) &#123; fastIndex = fastIndex.next; &#125; while(fastIndex.next != null) &#123; fastIndex = fastIndex.next; slowIndex = slowIndex.next; &#125; slowIndex.next = slowIndex.next.next; return dummyNode.next; &#125;&#125; 总结 双指针的应用，注意while结束的时候让慢指针指向倒数第n个结点的前一个结点（便于删除） 看了题解秒杀hhh","tags":["算法题","链表","双指针法"],"categories":["算法题"]},{"title":"leetcode-209:长度最小的子数组","path":"/2023/02/10/leetcode-209-长度最小的子数组/","content":"题目描述 找出该数组中满足其和 ≥target的长度最小的连续子数组 [numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度。如果不存在符合条件的子数组，返回0。 输入描述 一个含有n个正整数的数组和一个正整数target。 示例1 输入 target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] 输出 2 解释 子数组 [4,3] 是该条件下的长度最小的子数组 示例2 输入 target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1] 输出 0 思路 暴力搜索：定义两层for循环，遍历所有的起点和终点位置，找到符合条件的最短的数组，但时间复杂度过高，Java会保超时，时间复杂度O（n^2）。 滑动窗口：只定义一层for循环，遍历结束位置，但精妙之处在于，实现定义一个起点为0的指针left，从第一次找到sum&gt;&#x3D;target的时候开始，定义一个while循环（注意是while，因为可能有减去两个的时候sum还大于target）再让sum-=[left++]，最终实现只用一个for循环遍历，时间复杂度O（n）。 代码实现1234567891011121314151617class Solution &#123; //暴力搜索 public int minSubArrayLen(int target, int[] nums) &#123; int minLength = Integer.MAX_VALUE; for(int i = 0;i &lt;= nums.length - 1;i++) &#123; int sum = 0; for(int j = i;j &lt;= nums.length - 1;j++) &#123; sum += nums[j]; if(sum &gt;= target) &#123; minLength = Math.min(minLength, j - i + 1); break; &#125; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 12345678910111213141516class Solution &#123;\t//滑动窗口 public int minSubArrayLen(int target, int[] nums) &#123; int sum = 0; int left = 0; int result = Integer.MAX_VALUE; for(int right = 0;right &lt;= nums.length - 1;right++) &#123; sum += nums[right]; while(sum &gt;= target) &#123; result = Math.min(result, right - left +1); sum -= nums[left++]; &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 总结 暴力搜索就写了半天，还是太菜了，忘记距离的计算需要+1了。 遍历结束位置而非开始位置。","tags":["算法题","数组","滑动窗口"]},{"title":"leetcode-977:有序数组的平方","path":"/2023/02/09/leetcode-977-有序数组的平方/","content":"题目描述 给你一个按非递减顺序排序的整数数组nums，返回每个数字的平方组成的新数组，要求也按&#96;非递减顺序排序。 输入描述 非递减数组 示例1 输入： nums &#x3D; [-4,-1,0,3,10] 输出： [0,1,9,16,100] 解释： 平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例2： 输入： nums &#x3D; [-7,-3,2,3,11] 输出： [4,9,9,49,121] 思路可以直接暴力排序 i.e.全部平方之后排序，但时间复杂度过高，使用快排也是O(n+nlogn)，考虑到输入给的是非递减数组，所以最大值肯定在开头或结尾，可以考虑双指针法，从两边向中间逼近，注意考虑while循环的条件，要把leftIndex &#x3D; rightIndex的时候考虑进去。 代码实现12345678910111213141516171819class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int[] result = new int[nums.length]; int i = 0; int j = nums.length - 1; int resultIndex = nums.length - 1; while(j &gt;= i) &#123; if(nums[j] * nums[j] &gt;= nums[i] * nums[i]) &#123; result[resultIndex] = nums[j] * nums[j]; j--; &#125;else &#123; result[resultIndex] = nums[i] * nums[i]; i++; &#125; resultIndex--; &#125; return result; &#125;&#125;","tags":["算法题","双指针法","数组"],"categories":["算法题"]},{"title":"RF-diary","path":"/2023/02/09/RF-diary/","content":"目的：通过无线信号描述人的活动以及与物品的交互。 creating a system that observes people at home, and automatically generates a transcript of their everyday life。 创新点&#x2F;方法： 训练阶段将家庭平面图（标记家具等静态物体的大小和位置）输入网络中 将RF-diary提取到的特征与现有的视频字幕模型的特征对其到相同的空间 实验设计： 硬件条件：两个垂直和水平排列的12天线天线阵列，发射5.4-7.2GHz的FMCW 模型设计： RF Siganl： Input: 90-frame RF heatmaps（3 seconds） Network: 20(12 + 6 + 2)ResNet Floormap representation: Input:以人为中心建立坐标系，每个实例中用5个元素描述物体对象：L,W,x(t),y(t),theat Network:2 fully connected network Embedding layer: $u &#x3D; \\psi (u_{rf}\\oplus u_{flr})$$$u &#x3D; \\psi (u_{rf}\\oplus u_{flr})$$ $\\psi$指的是2层全连接 特征对齐： 对齐方法：先采一对RF+floormap特征与RGB视频作为配对数据（具有相同的语义），然后利用配对视频与现有的视频字幕数据集中视频具有相同模态的特点，建立桥梁； 具体实施：将有（RF+Floormap）配对的数据和无（RF+Floormap）配对数据混在一起训练一个视频字幕模型，然后迁移，但因为特征分布不同，会过拟合，所以利用让两个特征分布相似来解决（视频编码阶段提取两种特征Mixed_5c与空间平均池化后的特征），表现在loss上就是：$$\\begin{aligned}\\mathcal{L}&#x3D; &amp; \\mathcal{L}{\\text {cap }}\\left(\\mathbf{u}^P\\right)+\\mathcal{L}{\\text {cap }}\\left(\\mathbf{v}n^P\\right)+\\mathcal{L}{\\text {cap }}\\left(\\mathbf{v}n^U\\right) \\&amp; +\\mathcal{L}{\\text {pair }}\\left(\\mathbf{u}^P, \\mathbf{v}n^P\\right) \\&amp; +\\mathcal{L}{\\text {unpair }}\\left(\\mathbf{v}_n^P, \\mathbf{v}n^U\\right)+\\mathcal{L}{\\text {unpair }}\\left(\\mathbf{v}_m^P, \\mathbf{v}_m^U\\right) .\\end{aligned}$$ Loss： Lcap：针对的是字幕生成模型，第一个为最终目标，后两个应该是在混合训练的时候优化了； Lpair：针对的是embedding layer（maybe），让提取到的特征与具有相同语义的视频有最小的分布差； Lunpair：针对的是视频数据之间的分布差，不懂这个loss是怎么参与网络优化的 困惑： 用混合的视频数据训练了一个视频字幕生成模型，迁移下来时候，不就是输入带RF的数据集嘛，咋实现对两套视频数据分布差缩小的优化的（第三行unpair的loss），or实现之后又怎么反馈到其他部分啊？是在训练视频编码器的时候就做吗？但是在5.1中说他是直接用的别人训练好的模型提取视频特征。 怎么训练的&#x2F;优化的到底是啥？ 猜想1（整体训练）: 事先训练好特征提取网络、视频编码网络 （混合）视频数据训练出来的视频字幕模型 以3+1+2个loss最小为目标，不断优化captioning generation网络（基于注意力机制的LSTM模型） 但是这样训练，视频都已经用过了 猜想2： 未训练的特征提取网络 （混合）视频数据预训练出来的视频字幕模型 Question：输入的数据集应该是对应的rf+video+描述，得到一个能根据rf生成字幕的（或许是用混合数据预训练的）模型，然后对骨架编码器、floormap编码器、embedding层、 实验： 数据集：RF Captioning Dataset（synchronized RF signals, RGB videos, floormaps, human-labeled captions） floormaps：cabinet, table, bed, wardrobe, shelf, drawer, stove, fridge, sink, sofa, television, door, window, air conditioner, bathtub, dishwasher, oven, bedside table #environments #clips avg len #action types #object types #sentences #words vocab len 10 1035 31.3s 157 38 3610 77762 6910 8.99hrs 实验结果： 定量结果： 消融实验： 3D Skeleton: 3D skeletons &gt; 2D skeletons &gt; Locations Person-Centric Floormap: 应用：结论： 可见场景中与视频字幕模型效果相当（41.5 BLEU + 26.7 CIDEr VS 41.1 BLEU + 27.0 CIDEr） 遮蔽与黑暗场景效果依旧 总结： 多模态应用的思想：找到媒介，然后全部对齐 缺陷： 家具不能动 采集原始数据比较困难 启示：","tags":["wifi sensing","posing"],"categories":["文献阅读"]},{"title":"leetcode-704:二分查找","path":"/2023/02/09/leetcode-704-二分查找/","content":"题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 输入描述 可以假设 nums 中的所有元素是不重复的。 示例1 输入： nums &#x3D; [-1,0,3,5,9,12],target &#x3D; 9 输出： 4 解释： 9 出现在 nums 中并且下标为 4 示例2 输入： nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2 输出： -1 解释： 2 不存在 nums 中因此返回 -1 思路二分搜索法查找目标值。需要特别注意搜索区间，如果循环中定义的是左闭右闭（即left&lt;&#x3D;right）那么在缩小区间时需要变为mid+-1（因为闭区间上已经搜索过值了，避免重复搜索导致超出时间限制）。 代码实现12345678910111213141516class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left&lt;=right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) &#123; return mid; &#125; else if(nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 总结 循环条件无比要注意啊，不然编译过了，测试不通过（超出时间限制） 左闭右开也可以，缩小区间的时候不要+-1了","tags":["算法题","数组","二分法"],"categories":["算法题"]},{"title":"leetcode-511:游戏玩法分析I","path":"/2023/02/08/leetcode-511-游戏玩法分析I/","content":"题目描述 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。 leetcode-551 输入描述 create table activity ( player_id int, device_id int, event_date date, games_played int); insert into activity values(1, 2, ‘2016-03-01’, 5),(1, 2, ‘2016-05-02’, 6),(1, 3, ‘2017-06-25’, 1),(3, 1, ‘2016-03-02’, 0),(3, 4, ‘2018-07-03’, 5); 思路 按照 player_id 将 activity 分组 使用 min 函数，求出日期的最小值 代码实现123select player_id, min(event_date) as first_login from activitygroup by player_id; 总结 第一次见date类型的，不知道怎么比较 没想到用GROUP分组","tags":["算法题","MySql"],"categories":["数据库"]},{"title":"HashTable","path":"/2023/02/08/HashTable/","content":"哈希表也称散列表，英文名Hash table。 哈希表是根据关键码的值而直接进行访问的数据结构。 “数组就是一张哈希表” ：数组的索引下标就对应哈希表中的关键码，通过下标直接访问数组中的元素。 作用：一般哈希表都是用来快速判断一个元素是否出现集合里。 例如要查询一个名字是否在这所学校里。 要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。 我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。 将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。 哈希函数将学生姓名直接映射为哈希表上的索引，通过查询索引下标快速判断学生是否在学校里。 如果hashCode值大于tableSize，就对其取模，如果学生数量大于哈希表大小，会导致几位学生的名字同时影射到哈希表的同一个索引下标的位置。 哈希碰撞小王和小李都映射到了索引下标1的位置成为哈希碰撞（Collisions）。 一般通过拉链法与线性探测法解决。 拉链法：两个元素都被存在索引1的位置上，存储在链表中，由此可以通过索引找到两个元素。 “其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。” 线性探测法保证哈希表大小（tableSize）大于数据规模（dataSize）。依靠哈希表中的空位来解决碰撞问题。 “例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize。” 总结用处：快所安段一个元素是否出现在集合里 弊端：牺牲空间换取时间（要使用额外的数组、set或者map来存放数据）","categories":["数据结构"]},{"title":"Hello World","path":"/2023/02/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"关于我","path":"/about/index.html","content":"I’m GlonhChiang。I’m studying for a master degree at BUPT (2022.9 ~ 2025.6).Graduated from NJUPT(2018.9 ~ 2022.6).I mainly write Python and Java codes.I now focus on WiFi sensing and Deep Learning."}]